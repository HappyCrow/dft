TODO
====

- put incoming messages of the MDS into a priority queue
  - state updating messages must be processed with a higher priority
    than executing commands
    - use ZMQ.Socket.has_more to know if we can read more messages
    - batch at most N messages before processing the state updates
      first. Process messages immediately if less than N are available

- files in the datastore should be in read-only mode for
  the owner only (UGO right 400)

COMMANDS SEMANTICS
==================

1) start
   - the MDS
   - then the MDS starts all DSs

3) put a file

4) put a directory
   TODO: recursive put file on all the content of the dir

PERFORMANCE
===========

- it will be cheap to encode/decode on the fly
- it may be cheap to implement a chunk-level binary cache on DSs
  - just check the checksum of incoming packets

- use LZ4 for on-the-fly compression

maybe there should be a priority queue to sort incoming packets
(commands, state update, data transfers).
Maybe state update should be the highest priority in the MDS.
Use round robin for the moment.

- interesting worst case to test:
  many hosts ask for the same small file at the same time
  (if there is no load balancing, then the system behaves badly)

SECURITY
========

- for encryption: try AES and twofish
  - then prefer the one with the highest bitrate

- before executing a command from the CLI, a DS or MDS
  could verify the signature of the command.
  only commands signed with the private key of the user
  who started DAFT should be executed

- the MDS will do queries based on file-names
  - chunks should be stored in a data structure that is cheap to randomize
