TODO
====

- implement extract

- then implement get as fetch (if needed) then extract

- put incoming messages of the MDS into a priority queue
  - initial queue size is 3 times the number of DSs
  - state updating messages must be processed with a higher priority
    than executing commands
    - use ZMQ.Socket.has_more to know if we can read more messages
    - batch at most N messages before processing the state updates
      first. Process messages immediately if less than N are available

- all the ZMQ.send can be made asynchronous
  - only the receive must not be

COMMANDS SEMANTICS
==================

1) get a file

1') rget: get on a remote DS

2) start
   - then the MDS starts all DSs

4) put a directory
   TODO: recursive put file of all the content of the dir

PERFORMANCE
===========

- it will be cheap to encode/decode on the fly
- it may be cheap to implement a chunk-level binary cache on DSs
  - just check the checksum of incoming packets

- use LZ4 for on-the-fly compression

- interesting worst case to test:
  many hosts ask for the same small file at the same time
  (if there is no load balancing, then the system behaves badly)

SECURITY
========

- encryption of messages: if a message cannot be decrypted, then
  it is not from a member of the communication group (because it is from
  someone who doesn't know the group's secret)
  encryption_key: symmetric key used to encrypt and decrypt
  secret_key: int; prepended to all messages with salt
  salt: int; random
  to_encrypt = secret ^ salt ^ message
  // the encryption_key plus the secret_key are shared between CLI, MDS and DS)
  to_send = crypt (encryption_key, to_encrypt)

- decryption of messages
  to_check = decrypt (encryption_key, message)
  if to_check starts_with secret_key then
    OK
  else
    Fail

- for signing messages, just use a MAC from cryptokit
  cryptokit-1.10/_build/src/api-cryptokit.docdir/Cryptokit.MAC.html
  hmac_sha1 would be fine

- for encryption: try AES and twofish
  - then prefer the one with the highest bitrate
  - use a stream cipher some day if better for performance
    (high bitrate + not growing messages are nice properties)

- before executing a command from the CLI, a DS or MDS
  could verify the signature of the command.
  only commands signed with the private key of the user
  who started DAFT should be executed

- the MDS will do queries based on file-names
  - chunks should be stored in a data structure that is cheap to randomize

PUBLIC RELATIONS
================

 - advertize first beta release on several mailing lists for
   computational scientists
   - caml-list
   - comp. chem. ML
   - open babel ML
   - CCP4 ML
   - cryptography ML
